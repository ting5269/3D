<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 立方體展示</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }
        canvas { display: block; }
        .speed-control {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }
        .dot {
            width: 15px;
            height: 15px;
            background-color: gray;
            border-radius: 50%;
            cursor: pointer;
        }
        .active {
            background-color: white;
        }
    </style>
</head>
<body>
    <div class="speed-control">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
    </div>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/starfield.png', function (texture) {
            scene.background = texture;
        });

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshStandardMaterial({ color: 0x87CEFA, metalness: 0.7, roughness: 0.3 });
        const cube = new THREE.Mesh(geometry, material);
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);

        camera.position.z = 5;

        let speedLevels = [0.01, 0.02, 0.03, 0.04, 0.05, 0];
        let speedIndex = 0;
        let rotateX = 0;
        let rotateY = 0;
        let isMouseDown = false;
        let touchStartX = 0, touchStartY = 0;

        const dots = document.querySelectorAll('.dot');
        function updateSpeed() {
            dots.forEach((dot, index) => {
                dot.classList.toggle('active', index < speedIndex);
            });
        }
        updateSpeed();

        document.querySelector('.speed-control').addEventListener('click', () => {
            speedIndex = (speedIndex + 1) % speedLevels.length;
            updateSpeed();
        });

        window.addEventListener('mousedown', () => { isMouseDown = true; });
        window.addEventListener('mouseup', () => { isMouseDown = false; });

        window.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                rotateX = event.movementY * 0.005;
                rotateY = event.movementX * 0.005;
            }
        });

        window.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }
        });

        window.addEventListener('touchmove', (event) => {
            let touchX = event.touches[0].clientX;
            let touchY = event.touches[0].clientY;
            rotateX = (touchY - touchStartY) * 0.005;
            rotateY = (touchX - touchStartX) * 0.005;
            touchStartX = touchX;
            touchStartY = touchY;
        });

        function animate() {
            requestAnimationFrame(animate);
            cube.rotation.x += rotateX + speedLevels[speedIndex];
            cube.rotation.y += rotateY + speedLevels[speedIndex];
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
